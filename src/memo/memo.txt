<자바 시작 하기> : 클래스와 객체부턴 자세히 정리하고 그전까지는 간단하게 요약해서 정리할것 -> 정리 완료하면 삭제하기!
* 첫 프로그램 실행 해보기 
ex)package section1;

   public class HelloWorld { 
   
	 public static void main(String[] args) {
		System.out.println("HelloWorld");
	}
}
   ◎정리: ; → 문장의 마침표 역활하는 세미클론
 		 System.out.println → 화면에 출력하라는 뜻
            ㄴ>소문자로 쓰면 에러 발생!! 

 <변수>  
 * 프로그램에서 사용되는 자료를 저장하기 위한 공간
 * 할당 받은 메모리의 주소 대신 부르는 이름
 * 프로그램 실행 중에 값 변경 가능
 * 사용되기 이전에 선언 되어야 한다

 <변수의 선언과 초기화>
   ex) int level;  → level 이라는 이름의 변수 서언
       int level = 0; → level 변수 선언과 동시에 0 으로 초기화
       int level;
       level = 10;
       ◎정리 : int의 역할: level 변수의 데이터 타입을 저의
              int의 의미: level은 정수이며 4바이트의 메모리 공간을 사용함.
  

 <변수 선언 시 유의점>
 * 변수의 이름 알파벳, 숫자,_,$로 구성
 * 대소문자를 구분
 * 변수의 이름은 숫자로 시작할 수 없고, 키워드도 변수의 이름으로 사용할 수 없다.
 * 이름 사이에 공백이 있을 수 없다.
 * 변수의 이름을 정할 때는 변수의 역할에 어울리는, 의미 있는 이름을 지어야 한다.
 * 키워드를 변수로 사용할 수 없다.
 * 변수를 사용할 때 자료형에 따라 사용 가능한 수의 범위가 벗어나면 안됩니다.
    ex) byte Test = 200;
 
 <자료형>
 * byte: 1바이트 단위의 자료형
 	   동영상, 음삭 파일등 실행 파일의 자료를 처리 할 때 사용하기 좋은 자료형
 	   
 * short: 2바이트 단위의 자료형
 
 * int  : 자바에서 사용하는 정수에 대한 기본 자료형
 		4바이트 단위의 자료형
 		프로그램에서 사용하는 모든숫자(리터럴)은 기본적으로 int(4바이트)로 저장됨
 		32비트를 초과하는 숫자는 long 형으로 처리
 		
 * long : 8바이트 자료형
 		가장 큰 정수 자료형
 		숫자의 뒤에 L 또는 l을 써서 long 형임을 표시
 		ex) int num = 1234...; →  오류 발생!! int의 범위 넘은 값 대입
 		    long num = 123....; → 오류 발생!!숫자(리터럴)12345...은 기본형이 int 인데 int의 범위가 넘는 수
 		    ◎정리: 숫자(리터럴) 134........ 을 long으로 처리 하도록 명시
 		          long num = 12314....L;// 정상작동!! 소문자 l 써도 되지만 숫자 1 구분하기위해 대문자로 사용하는게 좋다.
 		          
 * char : 문자 자료형
 		  컴퓨터에서는 문자도 내부적으로는 비트의 조합으로 표현
 		  자바에서는 문자를 2바이트로 처리
 		  인코딩 → 각 문자에 따른 특정한 숫자 값(코드 값)을 부여
 		  디코딩 → 숫자 값을 원래의 문자로 변환
 		  ◎정리:한 문자만 출력 가능하고, 여러 문자는 출력할수 없다.(ex char a = abcd;)
 		       또한 문자세트 아스키,유니코드 표현할때 사용한다. 
 		       
 * float // double: 실수 자료형
   부동 소수점 방식: 실수를 지수부와 가수부로 표현
     			 무한의 실수를 표현하기 위한 방식		  
 	float (4바이트) double(8바이트)
 	
 	boolean: 논리형
 			 논리값true(참), false(거짓) 을 표현하는 자료형
 			 선언하는법은 boolean 으로 선언하면 된다.
 			 ex) boolean = Test = tue // false;
 			 
   ※ 자료형 없이 변수 사용하기( 자바 10 버전)
      자료형이 필요한 이유: 변수를 선언 할 때는 변수가 사용할 메모리 크기와
                  	   타입을 구분하기 위해 자료형 사용
     자역 변수 자료형 추론 : 변수에 대입되는 값을 보고 컴파일러가 추론함.
     
     ex) var num = 10;       	   int num = 10;
         var dnum = 10.0;      →   double dnum = 10.0;
         var str = "Test";         String str = "Test";
         
 <상수>
 * 상수: 변하지 않는 값(cf변수: 변하는 값)
 * 상수를 선언: final 키워드 사용 
 ex)final double PI = 3.14;
 	final int MAX_NUM = 100;
 ◎정리: final로 선언된 성수는 다른 값을 대입 할 수 없다.
 	   프로그램 내에서 변경되지 말아야 하는 값을 상수로 선언 해 두고
 	   혹시 변경되는 경우 선언된 값만 수정
 
 <리터럴>
 리터럴: 프로그램에서 사용하는 모든 숫자, 값, 논리 값
 	예)10, 3.14, 'A', true
 	   리터럴에 해당되는 값은 특정 메모리 공간인 상수 풀(constant pool)에 있다.
  	   필요한 경우 상수 풀에서 가져와서 사용
       상수 풀에 저장할때 정수는 int로 실수는 double로 저장
 ◎정리: 따라서 long 이나 float 값으로 저장해야 하는 경우 식별자 (L,I,F,f)
       를 명시 해야합니다.
 
 <형변환>
 형변환 : 자료형은 각각 사용하는 메모리 크기와 방식이 다름
        서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어 남
        묵시적 형변환: 작은 수에서 큰 수로 덜 정밀한 수에서 더 정밀한 수로 대입되는 경우 
        정수: byte(1바이트) → short(2바이트) → char(2바이트) → int(4바이트) → long(8바이트) 
        실수: float(4바이트)  → double(8바이트)
        예) long num 3; → int 값에서 long으로 자동 형 변환
        				 L,I을 명시하지 않아도 된다.
 명시적 형변환 : 묵시적 형 변환의 반대의 경우
      	      변환 되는 자료형을 명시해야 함 또는  자료의 손실이 발생 할수 있다.
      	예) double dNum = 3.14;
      	   int num = (int)dNum;  →자료형 명시
 
 <여러가지 연산자>
 /* 항과 연산자 
 * 항 : 연산에 사용되는 값
 * 연산자: 항을 이용하여 연산하는 기호
 * 
 * 항의 개수에 따른 연산자 구분
 * |연산자    |설명            |연산 예
 * 단항연산자  항이 한 개인 연산자   ++num
 * 이항연산자  항이 두 개인 연산자   num1 + num2;
 * 삼항연산자  항이 세 개인 연산자   (5<3)? 1:0;
 */

/* 대입 연산자
 * 변수에 값을 대입 하는 연산자
 * 연산의 결과를 변수에 대입 
 * 우선 수위가 가장 낮은 연산자
 * 왼쪽 변수에 오른쪽 변수값를 대입
 * ex) int age = 24; -> 나이를 의미하는 age 변수에 값 24를 대입
 *     totalScore = mathScore + engScore; 
 *     ㄴ> mathScore 값과 영어 점수 engScore 값을 더하여
 *        총점을 의미하는 tatalScore 변수에 수학 점수를 대입
 */
 
/* 관계 연산자
 * 이항 연산자 : 해당 연산의 실행을 위해서 두 개의 값이나 변수가 필요한 연산자를 의미
 * ★관계연산자참고
 * 연산자   | 기능                                              |연산ex
 *  >      왼쪽 항이 크면 참 아니면 거짓으로 반환                   num > 3;
 *  <      왼쪽 항이 작으면 참 , 아니면 거짓으로 반환                 num < 3;
 *  >=     왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓으로 반환  num >= 3;
 *  <=     왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓으로 반환  num <= 3;
 *  ==     두개 항의 값이 같으면 참, 아니면 거짓으로 반환              num == 3;
 *  !=     두개 항이 다르면 참, 아니면 거짓으로 반환                num != 3; 
 *  
 *  복합 대입 연산자
 *  대입 연산자와 다른 연산자를 함께 사용
 *  프로그램에서 자주 사용하는 연산자
 *  ★복합 대입연산자참고
 *  연산자   | 기능                                              |연산ex
 *  +=       두 항의 값을 더해서 왼쪽 항에 대입                        num > 3;
 *  -=       왼쪽 항에서 오른쪽 항을 뺴서 그 값을 왼쪽 항에 대입           num < 3;
 *  *=       두 항의 값을 곱해서 왼쪽 항에 대입                           num >= 3;
 *  /=       왼쪽 항을 오른쪽 항으로 나누어 그 몫을 왼쪽 항에 대입          num <= 3;
 *  %=       왼쪽 항을 오른쪽 항으로 나누어 그 나머지를 왼쪽 항에 대입        num == 3;
 *  <<=      비트를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입                num1 << 2; //num1 = << 2;와같음
 *  >>=      비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입             num1 >> 2; //num1 = >> 2;와같음                 
 *             ㄴ> 왼쪽에 채워지는 비트 값은 부호 비트와 동일
 *  >>>=     비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입              num1 >>>=2; //num1 = num1 >>> 2;와같음
 *             ㄴ>왼쪽에 채워지는 비트 값은 0
 *  &=       두 항의 & 비트 연산 후 그 값을 왼쪽 항에 대입                num1 & num2;  //num1 = num1 & num2;와같음
 *  |=       두 항의 | 비트 연산 후 그 값을 왼쪽 항에 대입                num1 |= num2; //num1 = num1 | num2;와같음
 *  ^=       두 항의 ^ 비트 연산 후 그 값을 왼쪽 항에 대입                num1 ^=num2;  //num1=num1 ^ num2;와같음
 *  
 *  조건 연산자
 *  삼항 연산자 : 조건 식의 결과가 true인 경우와 false인 경우에 따라 다른 식이나 결과가 수행
 *             제어문 중 조건문을 간단히 표현할때 사용할 수 있다.
 *  ★조건 연산자참고
 *  연산자              |기능                                         |연산ex 
 *  조건식?결과1: 결과2; 조건식이 참이면 결과1, 조건식이 거짓이면 결과2가 선택됨     int num =(5<3)? 10:20;
 *  
 *  비트 연산자
 *  비트 연산자는 정수에만 사용할 수있다.
 *  
 *  |연산자   |설명                |ex
 *    ~      비트의 반전(1의 보수)   a= ~a;
 *    &      비트 단위 AND         1 & 1 1반환 그 외는 0
 *    |      비트 단위 OR          0|0 0반환 그외는 1
 *    ^      비트 단위 XOR         두개의 비트가 서로 다른 경우에 1을 반환
 *    <<      왼쪽 shift           a<<2 변수를 a를 2비트 만큼 왼쪽으로 이동
 *    >>      오른쪽 shift         a<<2 변수를 a를 2비트 만큼 오른쪽으로 이동
 *    >>>     오른쪽 shift         >> 동일한 연산
 *                              ㄴ>채워지는 비트가 부호와 상관없이 0임     
 */
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 